<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monthly Summaries</title>
    <link rel="stylesheet" href="styles.css">

     <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y8VTYMEZFJ"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-Y8VTYMEZFJ');
    </script>

    <!-- Add Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- External CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
</head>
<body>
    <header>
        <div class="title">
            <h1>Cape Cod Ocean Watch</h1>
        </div>
        <div class="logos">
            <a href="https://capecodfishermen.org/" target="_blank">
                <img src="/logos/CCCFA_logo-removebg-preview.png" alt="Cape Cod Commercial Fishermen's Alliance Logo" class="cccfa-logo">
            </a>
            <a href="https://www.cfrfoundation.org" target="_blank">
                <img src="/logos/CFRF_logo.png" alt="CFRF Logo" class="cfrf-logo">
            </a>
            <a href="https://www.gomlf.org" target="_blank">
                <img src="/logos/gomlf_logo.png" alt="GOMLF Logo" class="gomlf-logo">
            </a>
            <a href="https://seagrant.whoi.edu/" target="_blank">
                <img src="/logos/seagrant_logo.png" alt="Sea Grant Logo" class="seagrant-logo">
            </a>
            <a href="https://www.whoi.edu/" target="_blank">
                <img src="/logos/WHOI_Tagline-Logo-1.png" alt="Woods Hole Oceanographic Institution Logo" class="whoi-logo">
            </a>
        </div>
    </header>

    <nav class="navbar">
        <ul>
            <li><a href="about.html">About</a></li>
            <li><a href="index.html">Mapped Profiles</a></li>
            <li><a href="time.html" class="active">Monthly Summaries</a></li>
            <li><a href="data-access.html">Data Access</a></li>
        </ul>
      </nav>

    <main class="content-container">
        <!-- Navigation Menu -->
        <nav class="page-nav">
            <h3 class="nav-title">Contents</h3>
            <div class="nav-section">
                <div class="nav-header" onclick="toggleNavSection(this)">
                    <h3>Average Monthly Surface Conditions</h3>
                    <i class="fas fa-chevron-down"></i>
                </div>
                <div class="nav-content">
                    <a href="#sst">Sea Surface Temperature</a>
                    <a href="#sss">Sea Surface Salinity</a>
                    <a href="#chl">Chlorophyll-a</a>
                </div>
            </div>
            <div class="nav-section">
                <div class="nav-header" onclick="toggleNavSection(this)">
                    <h3>Long Term Trends</h3>
                    <i class="fas fa-chevron-down"></i>
                </div>
                <div class="nav-content">
                    <a href="#temperature-trend">Map of Regions</a>
                    <a href="#anomaly-plots">Temperature & Salinity Time Series</a>
                </div>
            </div>
            <div class="nav-section">
                <div class="nav-header" onclick="toggleNavSection(this)">
                    <h3>Monthly Profiles</h3>
                    <i class="fas fa-chevron-down"></i>
                </div>
                <div class="nav-content">
                    <a href="#temperature-profiles">Temperature Profiles</a>
                    <a href="#salinity-profiles">Salinity Profiles</a>
                    <a href="#density-profiles">Density Profiles</a>
                </div>
            </div>
        </nav>

        <!-- Section 1: Monthly Averages -->
        <section id="monthly-averages" class="data-card">
            <h2>Monthly Averages</h2>
            
            <div id="sst">
                <h3>Sea Surface Temperature (SST)</h3>
                <p class="caption">Monthly average sea surface temperature from OSTIA satellite data.</p>
                <img src="../data/monthly_avg_pngs/OSTIA_SST_monthly_averages.png" 
                     alt="Monthly SST Averages" 
                     class="data-image">
            
                <p class="caption">Monthly SST anomalies using OSTIA monthly averages relative to a 2007-2024 OSTIA-derived climatology.</p>
                <img src="../data/monthly_avg_pngs/OSTIA_SST_combined_anomalies_2007_2024.png" 
                     alt="Monthly SST Anomaly Averages" 
                     class="data-image">
                            </div>

            <div id="sss">
                <h3>Sea Surface Salinity (SSS)</h3>
                <p class="caption">Monthly average sea surface salinity from SMAP satellite data. Salinity is measured 
                    in Practical Salinity Units (PSU), where 1 PSU is approximately 1 gram of salt per kilogram of 
                    seawater. The plots include contour lines at PSU levels of 34 and 35.</p>
                <img src="../data/monthly_avg_pngs/SMAP_SSS_monthly_averages.png" 
                     alt="SSS:" 
                     class="data-image">
                        </div>

            <div id="chl">
                <h3>Chlorophyll-a</h3>
                <p class="caption">Monthly average chlorophyll-a concentration from GlobColour satellite data. Chlorophyll-a 
                    is measured in milligrams per cubic meter (mg/m³) and serves as a proxy for phytoplankton biomass. 
                    Note the plots employ a log scale – slight changes in color can represent large changes in chlorophyll-a 
                    concentration.</p>
                <img src="../data/monthly_avg_pngs/GlobColour_CHL_monthly_averages.png" 
                     alt="CHL:" 
                     class="data-image">
            </div>
        </section>

        <!-- Section 2: Long Term Temperature Trend -->
        <section id="temperature-trend" class="data-card">
            <h2>Long Term Temperature & Salinity Trends</h2>
            
            <p class="caption">We define five regions of interest, shown in the map below: 
                the Gulf of Maine (GoM), Outer Cape (OC), Inner Cape (IC), Rhode Island (RI), and New Jersey (NJ). The SST/SSS data or anomaly 
                plots further below correspond to these regions. The GoM overlaps with both the OC and IC regions; these overlapping areas 
                are indicated by the shaded regions on the map. For each region, the daily anomaly is calculated as the difference between
                the region's spatially averaged daily/monthly observed SST/SSS and the long-term mean for that calendar day/month, based on the 
                combined spatial and temporal average across 2007–2024/2016 to 2024 for SST and SSS, respectively. The daily or monthly anomaly is then 
                averaged over the region to produce the region-averaged anomaly.
            </p>

            <h3>Regions:</h3>
            <!-- Region Map -->
            <div class="map-container">
                <div class="map-wrapper">
                    <img src="../data/OSTIA_SST/time_series/region_map.png" 
                         alt="Region Map" class="region-map">
                </div>
            </div>

            <h3>Time Series Plots:</h3>
            <p class="caption">Select a region and data type to view temperature and salinity plots. The temperature plot shows either daily values or anomalies (blue) with a 130-day rolling mean (red) for anomalies. The salinity plot shows monthly values or anomalies.</p>
            
            <!-- Region and Data Type Selectors -->
            <div class="region-selector">
                <div class="selector-group">
                    <label for="timeseries-region-select">Select Region:</label>
                    <select id="timeseries-region-select">
                        <option value="GoM">Gulf of Maine</option>
                        <option value="OC">Outer Cape</option>
                        <option value="IC">Inner Cape</option>
                        <option value="RI">Rhode Island</option>
                        <option value="NJ">New Jersey</option>
                    </select>
                </div>
                <div class="selector-group">
                    <label for="data-type-select">Select Data Type:</label>
                    <select id="data-type-select">
                        <option value="values">Observed Values</option>
                        <option value="anomalies">Calculated Anomalies</option>
                    </select>
                </div>
            </div>

            <!-- Time Series Plots -->
            <div class="timeseries-plots" id="anomaly-plots">
                <div class="plot-section">
                    <h3 id="sst-plot-title">Sea Surface Temperature Anomaly</h3>
                    <div id="sst-anomaly-plot" class="plot-container"></div>
                </div>
                <div class="plot-section">
                    <h3 id="sss-plot-title">Sea Surface Salinity Anomaly</h3>
                    <div id="sss-anomaly-plot" class="plot-container"></div>
                </div>
            </div>

            <!-- Unit Selector -->
            <div id="unit-selector" class="unit-selector">
                <label>Select Unit System:</label>
                <input type="radio" id="imperial" name="unit" value="imperial" checked />
                <label for="imperial">Imperial (°F)</label>
                <input type="radio" id="metric" name="unit" value="metric" />
                <label for="metric">Metric (°C)</label>
            </div>
        </section>

        <!-- Section 3: CTD Profiles by Region -->
        <section id="ctd-profiles" class="data-card">
            <h2>CTD Profiles by Region</h2>
            <p class="caption">Select a region to view monthly CTD profiles for temperature, salinity, and density.
                The regions referenced here are the same as those used in the anomaly plots above. <b>You can scroll to the right to view more months.</b>
            </p>
            
            <!-- Region Selector -->
            <div class="region-selector">
                <label for="region-select">Select Region:</label>
                <select id="region-select">
                    <option value="GoM">Gulf of Maine</option>
                    <option value="OC">Outer Cape</option>
                    <option value="IC">Inner Cape</option>
                    <option value="RI">Rhode Island</option>
                    <option value="NJ">New Jersey</option>
                </select>
            </div>

            <!-- Plot Grid Explanation and Colorbar -->
            <!-- <p class="caption">
                <strong>Line color indicates the day of the month:</strong>
            </p> -->
            <div style="margin: 8px 0 16px 0; text-align: center;">
                <span style="font-size: 0.9em;">First Day of the Month</span>
                <span style="display: inline-block; width: 120px; height: 16px; vertical-align: middle; background: linear-gradient(to right, #30123b, #1e63b5, #29c6b1, #f7e225, #fc6a2c, #b0003a); margin: 0 8px;"></span>
                <span style="font-size: 0.9em;">Last Day of the Month</span>
            </div>
            <!-- Plot Grid -->
            <div class="ctd-plot-grid">
                <!-- Temperature Row -->
                <div class="plot-row" id="temperature-profiles">
                    <h3>Temperature</h3>
                    <div class="monthly-plots" id="temp-plots"></div>
                </div>
                
                <!-- Salinity Row -->
                <div class="plot-row" id="salinity-profiles">
                    <h3>Salinity</h3>
                    <div class="monthly-plots" id="sal-plots"></div>
                </div>
                
                <!-- Density Row -->
                <div class="plot-row" id="density-profiles">
                    <h3>Density</h3>
                    <div class="monthly-plots" id="dens-plots"></div>
                </div>
            </div>

            <!-- Unit Selector for CTD Profiles -->
            <div id="ctd-unit-selector" class="unit-selector">
                <label>Select Unit System:</label>
                <input type="radio" id="ctd-imperial" name="ctd-unit" value="imperial" checked />
                <label for="ctd-imperial">Imperial (°F, fathoms)</label>
                <input type="radio" id="ctd-metric" name="ctd-unit" value="metric" />
                <label for="ctd-metric">Metric (°C, meters)</label>
            </div>

        </section>
    </main>

    <footer>
        <div class="footer-container">
            <div class="footer-section left">
                For dashboard questions: 
                <a href="mailto:finn.wimberly@whoi.edu">finn.wimberly@whoi.edu</a>
            </div>
            <div class="footer-section center">
                All code available @
                <a href="https://github.com/finnwimberly/CCCFA_app_dev" target="_blank">
                    <img src="/logos/GitHub-Mark-removebg-preview.png" alt="GitHub">
                </a>
            </div>
            <div class="footer-section right">
                For science questions: 
                <a href="mailto:svenja.ryan@whoi.edu">sryan@whoi.edu</a>
            </div>
        </div>
    </footer>

    <style>
        /* Only keep styles specific to this page that aren't in styles.css */
        .content-container {
            max-width: 95%;
        }
        
        /* CTD Profile Styles */
        .region-selector {
            margin: 20px 0;
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .selector-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .region-selector select {
            padding: 8px 16px;
            font-size: 16px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
        }
        
        /* Time Series Plot Styles */
        .timeseries-plots {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        
        .plot-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .plot-section h3 {
            margin: 0;
            color: var(--primary);
        }
        
        .ctd-plot-grid {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        
        .plot-row {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .plot-row h3 {
            margin: 0;
            color: var(--primary);
        }

        .monthly-plots {
            display: flex;
            gap: 20px;
            overflow-x: auto;
            padding: 10px 0;
        }
        
        .monthly-plot {
            min-width: 300px;
            height: 400px;
            background: white;
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        /* Navigation menu styles */
        .nav-section {
            margin-bottom: 10px;
        }

        .nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
            cursor: pointer;
        }

        .nav-header:hover {
            background-color: #e9e9e9;
        }

        .nav-content {
            display: none;
            padding: 10px;
            background-color: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
        }

        .nav-content a {
            display: block;
            padding: 5px 10px;
            color: #333;
            text-decoration: none;
        }

        .nav-content a:hover {
            background-color: #f5f5f5;
        }

        .nav-content a.active {
            background-color: #e9e9e9;
            font-weight: bold;
        }

        .nav-header i {
            transition: transform 0.3s ease;
        }
    </style>

    <script src="https://cdn.plot.ly/plotly-2.27.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3.0.0/dist/d3-scale-chromatic.min.js"></script>
    <script type="module">
        import { loadProfilesMetadata, loadMeasurementData } from './scripts/data-loading.js';

        // Function to convert temperature anomaly
        // function convertTemperatureAnomaly(value, toImperial) {
        //     if (toImperial) {
        //         return value * 1.8;  // °C to °F (just scaling)
        //     } else {
        //         return value / 1.8;  // °F to °C (just scaling)
        //     }
        // }

        function convertTemperature(value, toImperial, { anomaly = false } = {}) {
            if (!toImperial) {
                // Source is °C; if we're staying metric, do nothing
                return value;
            }
            // Convert to °F
            return anomaly ? value * 1.8 : (value * 9/5) + 32;
            }

        // Function to load SST data
        async function loadSSTData() {
            const response = await fetch('../data/OSTIA_SST/time_series/sst_timeseries.json');
            // const response = await fetch('/data/processed_data/OSTIA_SST/time_series/sst_timeseries.json');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            console.log('Loaded SST data:', data);
            return data;
        }

        // Function to load SSS data
        async function loadSSSData() {
            const response = await fetch('../data/SSS/time_series/sss_timeseries.json');
            // const response = await fetch('/data/processed_data/SSS/time_series/sss_timeseries.json');
                if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            console.log('Loaded SSS data:', data);
            
            // Debug: Check the structure of each region
            Object.keys(data).forEach(region => {
                console.log(`SSS region ${region} keys:`, Object.keys(data[region]));
                if (data[region].sss) {
                    console.log(`SSS region ${region} sss keys:`, Object.keys(data[region].sss).slice(0, 5));
                }
            });
            
            return data;
        }

        // Global flag to prevent infinite loops in synchronized zooming
        let isUpdatingSST = false;
        let isUpdatingSSS = false;

        // // Function to create SST plot for selected region
        // function createSSTPlot(sstData, selectedRegion, dataType) {
        //     if (!sstData[selectedRegion]) {
        //         console.error(`No SST data found for region ${selectedRegion}`);
        //         return;
        //     }

        //     const isImperial = document.getElementById('imperial').checked;
        //     const unit = isImperial ? '°F' : '°C';
            
        //     // Choose data based on dataType
        //     const sstDataKey = dataType === 'anomalies' ? 'ssta' : 'sst';
        //     const sstDataValues = sstData[selectedRegion][sstDataKey];

        //     // Check if the data exists
        //     if (!sstDataValues) {
        //         console.error(`No ${sstDataKey} data found for region ${selectedRegion}`);
        //         console.log('Available keys in region:', Object.keys(sstData[selectedRegion]));
        //         return;
        //     }

        //     // Convert data to arrays for Plotly, filtering out null values
        //     const times = [];
        //     const values = [];
            
        //     Object.entries(sstDataValues).forEach(([time, value]) => {
        //         if (value !== null && value !== undefined && !isNaN(value)) {
        //             times.push(time);
        //             if (dataType === 'anomalies') {
        //                 values.push(convertTemperatureAnomaly(value, isImperial));
        //             } else {
        //                 values.push(convertTemperatureAnomaly(value, isImperial)); // Convert temperature values
        //             }
        //         }
        //     });

        //     // Calculate 130-day rolling mean for both anomalies and raw data
        //     const windowSize = 130;
        //     const halfWindow = Math.floor(windowSize / 2);
        //     const rollingMean = [];
        //     for (let i = 0; i < values.length; i++) {
        //         if (i < halfWindow || i > values.length - halfWindow - 1) {
        //             rollingMean.push(null);
        //         } else {
        //             const start = i - halfWindow;
        //             const end = i + halfWindow + 1;
        //             const window = values.slice(start, end);
        //             rollingMean.push(window.reduce((a, b) => a + b, 0) / window.length);
        //         }
        //     }

        //     // Create traces
        //     const rawTrace = {
        //         x: times,
        //         y: values,
        //         name: dataType === 'anomalies' ? 'Daily Temperature Anomaly' : 'Daily Temperature',
        //         type: 'scatter',
        //         mode: 'lines',
        //         line: { 
        //             color: '#1f77b4',
        //             width: 1
        //         }
        //     };

        //     const traces = [rawTrace];
            
        //     // Add rolling mean trace for both anomalies and raw data
        //     const meanTrace = {
        //         x: times,
        //         y: rollingMean,
        //         name: '130-day Rolling Mean',
        //         type: 'scatter',
        //         mode: 'lines',
        //         line: { 
        //             color: '#ff4444',
        //             width: 2
        //         }
        //     };
        //     traces.push(meanTrace);

        //     // Update plot title
        //     const titleElement = document.getElementById('sst-plot-title');
        //     titleElement.textContent = dataType === 'anomalies' ? 
        //         'Sea Surface Temperature Anomaly' : 'Sea Surface Temperature';

        //     // Create the layout
        //     const layout = {
        //         height: 400,
        //         showlegend: true,
        //         legend: {
        //             x: 0.98,
        //             y: 0.98,
        //             xanchor: 'right',
        //             yanchor: 'top',
        //             bgcolor: 'rgba(255, 255, 255, 0.8)',
        //             bordercolor: 'lightgray',
        //             borderwidth: 1
        //         },
        //         title: {
        //             text: `${sstData[selectedRegion].name} - ${dataType === 'anomalies' ? 'SSTA' : 'SST'}`,
        //             font: { size: 16 },
        //             x: 0.05,
        //             xanchor: 'left',
        //             y: 0.95
        //         },
        //         xaxis: {
        //             title: 'Time',
        //             showgrid: true,
        //             gridcolor: 'lightgray'
        //         },
        //         yaxis: {
        //             title: dataType === 'anomalies' ? 
        //                 `Temperature Anomaly (${unit})` : 
        //                 `Temperature (${unit})`,
        //             showgrid: true,
        //             gridcolor: 'lightgray'
        //         },
        //         plot_bgcolor: 'white',
        //         paper_bgcolor: 'white',
        //         font: {
        //             family: 'Inter, sans-serif'
        //         },
        //         margin: { t: 60, b: 50, l: 50, r: 50 }
        //     };

        //     // Create the figure
        //     const config = {
        //         responsive: true,
        //         displayModeBar: true,
        //         modeBarButtonsToAdd: ['drawline', 'drawopenpath', 'eraseshape'],
        //         modeBarButtonsToRemove: ['lasso2d']
        //     };

        //     const sstPlot = Plotly.newPlot('sst-anomaly-plot', traces, layout, config);
            
        //     // Add event listener for synchronized zooming
        //     document.getElementById('sst-anomaly-plot').on('plotly_relayout', function(eventData) {
        //         if (eventData['xaxis.range[0]'] && eventData['xaxis.range[1]'] && !isUpdatingSSS) {
        //             isUpdatingSST = true;
        //             // Sync the SSS plot with the same time range
        //             Plotly.relayout('sss-anomaly-plot', {
        //                 'xaxis.range[0]': eventData['xaxis.range[0]'],
        //                 'xaxis.range[1]': eventData['xaxis.range[1]']
        //             }).then(() => {
        //                 isUpdatingSST = false;
        //             });
        //         }
        //     });
        // }


        function createSSTPlot(sstData, selectedRegion, dataType) {
            if (!sstData[selectedRegion]) {
                console.error(`No SST data found for region ${selectedRegion}`);
                return;
            }

            const isImperial = document.getElementById('imperial').checked;
            const unit = isImperial ? '°F' : '°C';

            const sstDataKey = dataType === 'anomalies' ? 'ssta' : 'sst';
            const sstDataValues = sstData[selectedRegion][sstDataKey];
            if (!sstDataValues) {
                console.error(`No ${sstDataKey} data found for region ${selectedRegion}`);
                console.log('Available keys in region:', Object.keys(sstData[selectedRegion]));
                return;
            }

            const isAnomaly = dataType === 'anomalies';

            const times = [];
            const values = [];
            Object.entries(sstDataValues).forEach(([time, value]) => {
                if (value !== null && value !== undefined && !isNaN(value)) {
                times.push(time);
                values.push(convertTemperature(value, isImperial, { anomaly: isAnomaly }));
                }
            });

            // 130-day rolling mean (unchanged)
            const windowSize = 130;
            const halfWindow = Math.floor(windowSize / 2);
            const rollingMean = [];
            for (let i = 0; i < values.length; i++) {
                if (i < halfWindow || i > values.length - halfWindow - 1) {
                rollingMean.push(null);
                } else {
                const start = i - halfWindow;
                const end = i + halfWindow + 1;
                const window = values.slice(start, end);
                rollingMean.push(window.reduce((a, b) => a + b, 0) / window.length);
                }
            }

            const rawTrace = {
                x: times,
                y: values,
                name: isAnomaly ? 'Daily Temperature Anomaly' : 'Daily Temperature',
                type: 'scatter',
                mode: 'lines',
                line: { color: '#1f77b4', width: 1 }
            };

            const meanTrace = {
                x: times,
                y: rollingMean,
                name: '130-day Rolling Mean',
                type: 'scatter',
                mode: 'lines',
                line: { color: '#ff4444', width: 2 }
            };

            const layout = {
                height: 400,
                showlegend: true,
                legend: {
                x: 0.98, y: 0.98, xanchor: 'right', yanchor: 'top',
                bgcolor: 'rgba(255,255,255,0.8)', bordercolor: 'lightgray', borderwidth: 1
                },
                title: {
                text: `${sstData[selectedRegion].name} - ${isAnomaly ? 'SSTA' : 'SST'}`,
                font: { size: 16 }, x: 0.05, xanchor: 'left', y: 0.95
                },
                xaxis: { title: 'Time', showgrid: true, gridcolor: 'lightgray' },
                yaxis: {
                title: isAnomaly ? `Temperature Anomaly (${unit})` : `Temperature (${unit})`,
                showgrid: true, gridcolor: 'lightgray'
                },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white',
                font: { family: 'Inter, sans-serif' },
                margin: { t: 60, b: 50, l: 50, r: 50 }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToAdd: ['drawline', 'drawopenpath', 'eraseshape'],
                modeBarButtonsToRemove: ['lasso2d']
            };

            Plotly.newPlot('sst-anomaly-plot', [rawTrace, meanTrace], layout, config);

            // sync zoom (unchanged)
            document.getElementById('sst-anomaly-plot').on('plotly_relayout', function(eventData) {
                if (eventData['xaxis.range[0]'] && eventData['xaxis.range[1]'] && !isUpdatingSSS) {
                isUpdatingSST = true;
                Plotly.relayout('sss-anomaly-plot', {
                    'xaxis.range[0]': eventData['xaxis.range[0]'],
                    'xaxis.range[1]': eventData['xaxis.range[1]']
                }).then(() => { isUpdatingSST = false; });
                }
            });
            }


        // Function to create SSS plot for selected region
        function createSSSPlot(sssData, selectedRegion, dataType, sstTimeRange) {
            if (!sssData[selectedRegion]) {
                console.error(`No SSS data found for region ${selectedRegion}`);
                return;
            }

            // Choose data based on dataType
            const sssDataKey = dataType === 'anomalies' ? 'sssa' : 'sss';
            console.log(`Looking for ${sssDataKey} in region ${selectedRegion}`);
            console.log(`Region data:`, sssData[selectedRegion]);
            const sssDataValues = sssData[selectedRegion][sssDataKey];

            // Check if the data exists
            if (!sssDataValues) {
                console.error(`No ${sssDataKey} data found for region ${selectedRegion}`);
                console.log('Available keys in region:', Object.keys(sssData[selectedRegion]));
                
                // If raw SSS data is not available, show a message in the plot
                const layout = {
                    height: 400,
                    title: {
                        text: `${sssData[selectedRegion].name} - SSS`,
                        font: { size: 16 },
                        x: 0.05,
                        xanchor: 'left',
                        y: 0.95
                    },
                    annotations: [{
                        text: 'Raw SSS data not available. Only anomaly data is available for salinity.',
                        xref: 'paper',
                        yref: 'paper',
                        x: 0.5,
                        y: 0.5,
                        showarrow: false,
                        font: {
                            size: 14,
                            color: 'gray'
                        }
                    }],
                    plot_bgcolor: 'white',
                    paper_bgcolor: 'white',
                    font: {
                        family: 'Inter, sans-serif'
                    },
                    margin: { t: 60, b: 50, l: 50, r: 50 }
                };
                
                Plotly.newPlot('sss-anomaly-plot', [], layout);
                return;
            }

            // Convert data to arrays for Plotly, filtering out null values
            const times = [];
            const values = [];
            
            Object.entries(sssDataValues).forEach(([time, value]) => {
                if (value !== null && value !== undefined && !isNaN(value)) {
                    times.push(time);
                    values.push(value);
                }
            });

            // Create trace for monthly salinity data
            const sssTrace = {
                x: times,
                y: values,
                name: dataType === 'anomalies' ? 'Monthly Salinity Anomaly' : 'Monthly Salinity',
                type: 'scatter',
                mode: 'lines+markers',
                line: { 
                    color: '#1f77b4',
                    width: 2
                },
                marker: {
                    size: 4,
                    color: '#1f77b4'
                }
            };

            // Update plot title
            const titleElement = document.getElementById('sss-plot-title');
            titleElement.textContent = dataType === 'anomalies' ? 
                'Sea Surface Salinity Anomaly' : 'Sea Surface Salinity';

            // Create the layout with aligned time range if provided
            const layout = {
                height: 400,
                showlegend: true,
                legend: {
                    x: 0.98,
                    y: 0.98,
                    xanchor: 'right',
                    yanchor: 'top',
                    bgcolor: 'rgba(255, 255, 255, 0.8)',
                    bordercolor: 'lightgray',
                    borderwidth: 1
                },
                title: {
                    text: `${sssData[selectedRegion].name} - ${dataType === 'anomalies' ? 'SSSA' : 'SSS'}`,
                    font: { size: 16 },
                    x: 0.05,
                    xanchor: 'left',
                    y: 0.95
                },
                xaxis: {
                    title: 'Time',
                    showgrid: true,
                    gridcolor: 'lightgray',
                    range: sstTimeRange // Align with SST time range
                },
                yaxis: {
                    title: dataType === 'anomalies' ? 
                        'Salinity Anomaly (PSU)' : 
                        'Salinity (PSU)',
                    showgrid: true,
                    gridcolor: 'lightgray'
                },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white',
                font: {
                    family: 'Inter, sans-serif'
                },
                margin: { t: 60, b: 50, l: 50, r: 50 }
            };

            // Create the figure
            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToAdd: ['drawline', 'drawopenpath', 'eraseshape'],
                modeBarButtonsToRemove: ['lasso2d']
            };

            const sssPlot = Plotly.newPlot('sss-anomaly-plot', [sssTrace], layout, config);
            
            // Add event listener for synchronized zooming (reverse direction)
            document.getElementById('sss-anomaly-plot').on('plotly_relayout', function(eventData) {
                if (eventData['xaxis.range[0]'] && eventData['xaxis.range[1]'] && !isUpdatingSST) {
                    isUpdatingSSS = true;
                    // Sync the SST plot with the same time range
                    Plotly.relayout('sst-anomaly-plot', {
                        'xaxis.range[0]': eventData['xaxis.range[0]'],
                        'xaxis.range[1]': eventData['xaxis.range[1]']
                    }).then(() => {
                        isUpdatingSSS = false;
                    });
                }
            });
        }

        // Function to create unified time series plots
        async function createTimeSeriesPlots(selectedRegion, dataType) {
            try {
                // Load both SST and SSS data
                const sstData = await loadSSTData();
                const sssData = await loadSSSData();
                
                // Debug: Log the data structure
                console.log('SST Data structure:', sstData);
                console.log('SSS Data structure:', sssData);
                
                // Create SST plot for selected region
                createSSTPlot(sstData, selectedRegion, dataType);
                
                // Get SST time range for alignment
                const sstDataKey = dataType === 'anomalies' ? 'ssta' : 'sst';
                const sstDataValues = sstData[selectedRegion]?.[sstDataKey];
                
                // Check if SST data exists before getting time range
                let sstTimeRange = null;
                if (sstDataValues) {
                    const sstTimes = Object.keys(sstDataValues);
                    sstTimeRange = sstTimes.length > 0 ? [sstTimes[0], sstTimes[sstTimes.length - 1]] : null;
                }
                
                // Create SSS plot for selected region with aligned time range
                createSSSPlot(sssData, selectedRegion, dataType, sstTimeRange);
            } catch (error) {
                console.error('Error creating time series plots:', error);
            }
        }

        // Function to initialize time series plots
        async function initializeTimeSeriesPlots() {
            try {
                const regionSelect = document.getElementById('timeseries-region-select');
                const dataTypeSelect = document.getElementById('data-type-select');
                
                // Add event listeners for region, data type, and unit changes
                regionSelect.addEventListener('change', (e) => {
                    createTimeSeriesPlots(e.target.value, dataTypeSelect.value);
                });
                
                dataTypeSelect.addEventListener('change', (e) => {
                    createTimeSeriesPlots(regionSelect.value, e.target.value);
                });
                
                // Add event listeners for unit changes (only affects SST)
                document.getElementById('imperial').addEventListener('change', () => {
                    createTimeSeriesPlots(regionSelect.value, dataTypeSelect.value);
                });
                document.getElementById('metric').addEventListener('change', () => {
                    createTimeSeriesPlots(regionSelect.value, dataTypeSelect.value);
                });
                
                // Initial plot with first region and default data type
                createTimeSeriesPlots(regionSelect.value, dataTypeSelect.value);
            } catch (error) {
                console.error('Error initializing time series plots:', error);
            }
        }

        // CTD Profile Plotting
        async function loadCTDProfiles() {
            try {
                // Set start date to August 2024
                const startDate = '2024-08-01';
                
                // Set end date to the last day of the current month
                const now = new Date();
                const endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0).toISOString().split('T')[0];
                
                console.log('Loading profiles from:', startDate, 'to', endDate);
                
                const profiles = await loadProfilesMetadata(
                    startDate,
                    endDate,
                    'CTD'
                );

                // Log the first profile to see its structure
                if (profiles.length > 0) {
                    console.log('First profile structure:', profiles[0]);
                    console.log('Available fields:', Object.keys(profiles[0]));
                }

                // Load measurement data for each profile
                const profilesWithData = await Promise.all(
                    profiles.map(async (profile) => {
                        // Get profile ID and validate it
                        const profileId = profile['Profile ID'];
                        if (!profileId) {
                            console.error('Missing Profile ID in profile:', profile);
                            return null;
                        }

                        console.log('Loading measurements for profile:', profileId);
                        try {
                            const measurements = await loadMeasurementData(profileId, 'CTD');
                            if (!measurements || !measurements.temperature || measurements.temperature.length === 0) {
                                console.error('No valid measurements for profile:', profileId);
                                return null;
                            }
                            return {
                                ...profile,  // Include all profile metadata
                                ...measurements
                            };
                        } catch (error) {
                            console.error('Error loading measurements for profile:', profileId, error);
                            return null;
                        }
                    })
                );

                // Filter out any failed profile loads
                const validProfiles = profilesWithData.filter(profile => profile !== null);
                console.log('Successfully loaded profiles:', validProfiles.length, 'out of', profiles.length);

                if (validProfiles.length === 0) {
                    console.error('No valid profiles were loaded');
                    return null;
                }

                return validProfiles;
            } catch (error) {
                console.error('Error loading CTD profiles:', error);
                return null;
            }
        }

        function createMonthlyPlots(data, region) {
            if (!data || data.length === 0) {
                console.error('No data available for plotting');
                return;
            }

            console.log('Total profiles to process:', data.length);
            console.log('Sample profile:', data[0]);

            // Filter profiles for the selected region
            const regionProfiles = data.filter(profile => {
                const regions = profile.Regions.split(',').map(r => r.trim());
                return regions.includes(region);
            });

            console.log(`Found ${regionProfiles.length} profiles in region ${region}`);

            // Group profiles by month and year
            const monthlyProfiles = {};
            regionProfiles.forEach(profile => {
                const date = new Date(profile.Date);
                const month = date.toLocaleString('default', { month: 'long' });
                const year = date.getFullYear();
                const key = `${year}-${month}`;  // Create a key that includes year
                if (!monthlyProfiles[key]) {
                    monthlyProfiles[key] = [];
                }
                monthlyProfiles[key].push(profile);
            });

            // Get all months in chronological order
            const startDate = new Date('2024-08-01');
            const endDate = new Date();
            const allMonths = [];
            
            // Set the current date to August 2024
            let currentDate = new Date(startDate);
            
            // Ensure we start from August by setting the month and year explicitly
            currentDate.setMonth(7); // 7 is August (0-based index)
            currentDate.setFullYear(2024);
            currentDate.setDate(1); // Set to first day of month
            
            while (currentDate <= endDate) {
                const month = currentDate.toLocaleString('default', { month: 'long' });
                const year = currentDate.getFullYear();
                allMonths.push(`${year}-${month}`);
                
                // Create a new date object for the next month
                const nextMonth = new Date(currentDate);
                nextMonth.setMonth(nextMonth.getMonth() + 1);
                nextMonth.setDate(1); // Ensure we're at the start of the month
                currentDate = nextMonth;
            }

            // Reverse the order of months to have the most recent first
            allMonths.reverse();

            // Function to convert units
            function convertUnits(value, type, toImperial) {
                if (type === 'temperature') {
                    return toImperial ? (value * 9/5) + 32 : (value - 32) * 5/9;
                } else if (type === 'depth') {
                    return toImperial ? value * 0.546807 : value / 0.546807; // meters to fathoms and vice versa
                }
                return value; // Return unchanged for other types
            }

            // Get current unit system
            const isImperial = document.getElementById('ctd-imperial').checked;
            const tempUnit = isImperial ? '°F' : '°C';
            const depthUnit = isImperial ? 'fathoms' : 'm';

            // Calculate overall temperature bounds across all data
            let allTemperatures = [];
            let allSalinities = [];
            let allDensities = [];
            
            regionProfiles.forEach(profile => {
                if (profile.temperature && profile.temperature.length > 0) {
                    const convertedTemps = profile.temperature.map(t => convertUnits(t, 'temperature', isImperial));
                    allTemperatures = allTemperatures.concat(convertedTemps);
                }
                if (profile.salinity && profile.salinity.length > 0) {
                    allSalinities = allSalinities.concat(profile.salinity);
                }
                if (profile.density && profile.density.length > 0) {
                    allDensities = allDensities.concat(profile.density);
                }
            });

            // Set temperature bounds with some padding
            let tempMin, tempMax;
            if (allTemperatures.length > 0) {
                const tempRange = Math.max(...allTemperatures) - Math.min(...allTemperatures);
                const padding = tempRange * 0.03; // 3% padding
                tempMin = Math.min(...allTemperatures) - padding;
                tempMax = Math.max(...allTemperatures) + padding;
            } else {
                // Default bounds if no temperature data
                tempMin = isImperial ? 39 : 3; // 39°F or 3°C
                tempMax = isImperial ? 70 : 21;  // 70°F or 21°C
            }

            // Set salinity bounds with some padding
            let salMin, salMax;
            if (allSalinities.length > 0) {
                const salRange = Math.max(...allSalinities) - Math.min(...allSalinities);
                const padding = salRange * 0.05; // 5% padding
                salMin = Math.min(...allSalinities) - padding;
                salMax = Math.max(...allSalinities) + padding;
            } else {
                // Default bounds if no salinity data
                salMin = 30; // 30 PSU
                salMax = 34.5; // 34.5 PSU
            }

            // Set density bounds with some padding
            let densMin, densMax;
            if (allDensities.length > 0) {
                const densRange = Math.max(...allDensities) - Math.min(...allDensities);
                const padding = densRange * 0.05; // 5% padding
                densMin = Math.min(...allDensities) - padding;
                densMax = Math.max(...allDensities) + padding;
            } else {
                // Default bounds if no density data
                densMin = 1020; // 1020 kg/m³
                densMax = 1027; // 1027 kg/m³
            }

            // Create plots for each variable
            const variables = {
                temp: { 
                    data: 'temperature', 
                    title: `Temperature (${tempUnit})`,
                    convert: (v) => convertUnits(v, 'temperature', isImperial),
                    xrange: [tempMin, tempMax]
                },
                sal: { 
                    data: 'salinity', 
                    title: 'Salinity (PSU)',
                    convert: (v) => v, // No conversion needed for salinity
                    xrange: [salMin, salMax]
                },
                dens: { 
                    data: 'density', 
                    title: 'Density (kg/m³)',
                    convert: (v) => v, // No conversion needed for density
                    xrange: [densMin, densMax]
                }
            };

            // Get all plot containers
            const plotContainers = {
                temp: document.getElementById('temp-plots'),
                sal: document.getElementById('sal-plots'),
                dens: document.getElementById('dens-plots')
            };

            // Add scroll event listeners to synchronize scrolling
            Object.values(plotContainers).forEach(container => {
                container.addEventListener('scroll', (e) => {
                    // Get the scroll position of the scrolled container
                    const scrollLeft = e.target.scrollLeft;
                    
                    // Set the same scroll position for all other containers
                    Object.values(plotContainers).forEach(otherContainer => {
                        if (otherContainer !== e.target) {
                            otherContainer.scrollLeft = scrollLeft;
                        }
                    });
                });
            });

            Object.entries(variables).forEach(([key, info]) => {
                const container = document.getElementById(`${key}-plots`);
                container.innerHTML = ''; // Clear existing plots

                // Create a plot for each month, even if no data
                allMonths.forEach(monthKey => {
                    const [year, month] = monthKey.split('-');
                    const plotDiv = document.createElement('div');
                    plotDiv.className = 'monthly-plot';
                    container.appendChild(plotDiv);

                    const profiles = monthlyProfiles[monthKey] || [];
                    
                    if (profiles.length === 0) {
                        // Create empty plot with "No data" message
                        const layout = {
                            title: `${month} ${year}`,
                            xaxis: { 
                                title: info.title,
                                range: info.xrange || [0, 1]  // Use fixed range for temperature, small range for others
                            },
                            yaxis: { 
                                title: `Depth (${depthUnit})`,
                                range: [0, 1]  // Set a small range for empty plot
                            },
                            annotations: [{
                                text: 'No CTDs collected',
                                xref: 'paper',
                                yref: 'paper',
                                x: 0.5,
                                y: 0.5,
                                showarrow: false,
                                font: {
                                    size: 16,
                                    color: 'gray'
                                }
                            }],
                            margin: { t: 40, r: 20, b: 40, l: 60 }
                        };
                        Plotly.newPlot(plotDiv, [], layout);
                    } else {
                        // Determine the date range for the month
                        const dates = profiles.map(profile => new Date(profile.Date));
                        const minDate = Math.min(...dates);
                        const maxDate = Math.max(...dates);

                        const traces = profiles.map(profile => {
                            const date = new Date(profile.Date);
                            const dayOfMonth = date.getDate();
                            const normalizedDay = (dayOfMonth - 1) / 30;
                            const color = d3.interpolateTurbo(normalizedDay);
                            const dateString = date.toLocaleDateString();

                            return {
                                y: profile.depth.map(d => convertUnits(d, 'depth', isImperial)),
                                x: profile[info.data].map(v => info.convert(v)),
                                type: 'scatter',
                                mode: 'lines',
                                name: dateString,
                                line: { width: 1, color: color },
                                hovertemplate: `Date: ${dateString}<br>X: %{x}<br>Y: %{y}<extra></extra>`
                            };
                        });

                        const layout = {
                            title: `${month} ${year}`,
                            xaxis: { 
                                title: info.title,
                                range: info.xrange // Use fixed range for temperature, undefined for others (autorange)
                            },
                            yaxis: { 
                                title: `Depth (${depthUnit})`,
                                autorange: 'reversed'
                            },
                            showlegend: false,
                            margin: { t: 40, r: 20, b: 40, l: 60 }
                        };

                        Plotly.newPlot(plotDiv, traces, layout);
                    }
                });
            });
        }


        // Initialize CTD profiles
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('Initializing CTD profiles...');
            const ctdData = await loadCTDProfiles();
            if (ctdData) {
                console.log('Successfully loaded CTD data');
                const regionSelect = document.getElementById('region-select');
                
                // Add event listeners for both region and unit changes
                regionSelect.addEventListener('change', (e) => {
                    createMonthlyPlots(ctdData, e.target.value);
                });
                
                // Add event listeners for unit changes
                document.getElementById('ctd-imperial').addEventListener('change', () => {
                    createMonthlyPlots(ctdData, regionSelect.value);
                });
                document.getElementById('ctd-metric').addEventListener('change', () => {
                    createMonthlyPlots(ctdData, regionSelect.value);
                });
                
                // Initial plot with first region
                createMonthlyPlots(ctdData, regionSelect.value);
            } else {
                console.error('Failed to load CTD data');
            }

            // Initialize time series plots
            console.log('Initializing time series plots...');
            await initializeTimeSeriesPlots();
        });

        // Navigation menu functionality
        function toggleNavSection(header) {
            const section = header.parentElement;
            const content = section.querySelector('.nav-content');
            const icon = header.querySelector('i');
            
            // Toggle active class
            section.classList.toggle('active');
            
            // Toggle content visibility
            if (section.classList.contains('active')) {
                content.style.display = 'block';
                icon.classList.remove('fa-chevron-down');
                icon.classList.add('fa-chevron-up');
            } else {
                content.style.display = 'none';
                icon.classList.remove('fa-chevron-up');
                icon.classList.add('fa-chevron-down');
            }
        }

        // Initialize navigation menu
        document.addEventListener('DOMContentLoaded', () => {
            // Set initial state of navigation sections
            document.querySelectorAll('.nav-section').forEach(section => {
                const content = section.querySelector('.nav-content');
                const icon = section.querySelector('.nav-header i');
                
                if (section.classList.contains('active')) {
                    content.style.display = 'block';
                    icon.classList.remove('fa-chevron-down');
                    icon.classList.add('fa-chevron-up');
                } else {
                    content.style.display = 'none';
                    icon.classList.remove('fa-chevron-up');
                    icon.classList.add('fa-chevron-down');
                }
            });

            // Add click handlers to all nav headers
            document.querySelectorAll('.nav-header').forEach(header => {
                header.addEventListener('click', () => toggleNavSection(header));
            });
        });
    </script>
</body>
</html>